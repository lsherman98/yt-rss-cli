package api_hooks

import (
	"bytes"
	"io"
	"net/http"

	"github.com/lsherman98/yt-rss/pocketbase/collections"
	"github.com/pocketbase/dbx"
	"github.com/pocketbase/pocketbase"
	"github.com/pocketbase/pocketbase/apis"
	"github.com/pocketbase/pocketbase/core"
	"github.com/pocketbase/pocketbase/tools/security"
)

type ConvertRequest struct {
	URLs []string `json:"urls"`
}

type JobResponse struct {
	ID               string         `json:"id"`
	URL              string         `json:"url"`
	Status           string         `json:"status"`
	DownloadEndpoint string         `json:"download_endpoint,omitempty"`
	VideoMetadata    *VideoMetadata `json:"video_metadata,omitempty"`
	Title            string         `json:"title,omitempty"`
	Created          string         `json:"created,omitempty"`
}

type VideoMetadata struct {
	Title       string `json:"title"`
	Description string `json:"description"`
	Duration    int    `json:"duration"`
	VideoID     string `json:"video_id"`
	Size        int    `json:"size"`
}

const (
	URLsLimit = 25
)

func Init(app *pocketbase.PocketBase) error {
	app.OnServe().BindFunc(func(se *core.ServeEvent) error {
		se.Router.GET("/api/generate-batch-id", func(e *core.RequestEvent) error {
			randomString := security.PseudorandomString(15)
			return e.JSON(200, map[string]any{
				"batchId": randomString,
			})
		}).Bind(apis.RequireAuth())

		se.Router.POST("/api/v1/convert", func(e *core.RequestEvent) error {
			body := ConvertRequest{}
			if err := e.BindBody(&body); err != nil {
				return e.BadRequestError("Invalid request body", err)
			}

			authHeader := e.Request.Header.Get("Authorization")
			if authHeader == "" {
				return e.UnauthorizedError("Missing Authorization header", nil)
			}

			apiKey := ""
			if len(authHeader) > 7 && authHeader[:7] == "Bearer " {
				apiKey = authHeader[7:]
			} else {
				return e.UnauthorizedError("Invalid Authorization header format", nil)
			}

			hashedAPIKey := security.SHA256(apiKey)
			apiKeyRecord, err := app.FindFirstRecordByData(collections.APIKeys, "hashed_key", hashedAPIKey)
			if err != nil || apiKeyRecord == nil {
				return e.UnauthorizedError("Invalid API key", nil)
			}

			userId := apiKeyRecord.GetString("user")
			user, err := e.App.FindRecordById(collections.Users, userId)
			if err != nil || user == nil {
				return e.UnauthorizedError("Invalid API key", nil)
			}

			tierId := user.GetString("tier")
			tier, err := e.App.FindRecordById(collections.SubscriptionTiers, tierId)
			if err != nil || tier == nil {
				return e.InternalServerError("something went wrong", nil)
			}

			if tier.GetString("lookup_key") == "free" {
				return e.ForbiddenError("Free tier users cannot use the API. Please upgrade your subscription.", nil)
			}

			if tier.GetString("lookup_key") == "basic_monthly" || tier.GetString("lookup_key") == "basic_yearly" {
				return e.ForbiddenError("Basic tier users cannot use the API. Please upgrade your subscription.", nil)
			}

			monthlyUsageRecords, err := e.App.FindRecordsByFilter(collections.MonthlyUsage, "user = {:user}", "-created", 1, 0, dbx.Params{
				"user": user.Id,
			})
			if err != nil || monthlyUsageRecords == nil {
				e.App.Logger().Error("Convert API: failed to find monthly usage record: " + err.Error())
				return e.Next()
			}
			monthlyUsage := monthlyUsageRecords[0]

			usageLimit := monthlyUsage.GetInt("limit")
			currentUsage := monthlyUsage.GetInt("usage")

			if currentUsage >= usageLimit {
				return e.ForbiddenError("Monthly usage limit exceeded", nil)
			}

			if len(body.URLs) == 0 || len(body.URLs) > URLsLimit {
				return e.BadRequestError("Invalid number of URLs, must be between 1 and "+string(rune(URLsLimit)), nil)
			}

			jobCollection, err := app.FindCollectionByNameOrId(collections.Jobs)
			if err != nil {
				return e.InternalServerError("internal server error", nil)
			}

			batchId := security.PseudorandomString(15)
			jobs := make([]JobResponse, 0, len(body.URLs))

			err = app.RunInTransaction(func(txApp core.App) error {
				for _, url := range body.URLs {
					jobRecord := core.NewRecord(jobCollection)
					jobRecord.Set("user", apiKeyRecord.GetString("user"))
					jobRecord.Set("url", url)
					jobRecord.Set("status", "CREATED")
					jobRecord.Set("batch_id", batchId)
					jobRecord.Set("api_key", apiKeyRecord.Id)
					if err := txApp.Save(jobRecord); err != nil {
						e.App.Logger().Error("API Hooks: failed to create job record: " + err.Error())
						return err
					}

					jobs = append(jobs, JobResponse{
						ID:     jobRecord.Id,
						URL:    url,
						Status: "CREATED",
					})
				}

				return nil
			})
			if err != nil {
				return e.InternalServerError("failed to create jobs", err.Error())
			}

			return e.JSON(http.StatusOK, map[string]any{
				"batch_id": batchId,
				"message":  "Jobs created successfully",
				"jobs":     jobs,
			})
		})

		se.Router.GET("/api/v1/poll/batch/{batchId}", func(e *core.RequestEvent) error {
			batchId := e.Request.PathValue("batchId")
			if batchId == "" {
				return e.BadRequestError("Missing batchId parameter", nil)
			}

			jobCollection, err := e.App.FindCollectionByNameOrId(collections.Jobs)
			if err != nil {
				return e.InternalServerError("internal server error", nil)
			}

			jobs, err := e.App.FindRecordsByFilter(jobCollection, "batch_id = {:batchId}", "", 0, 0, dbx.Params{"batchId": batchId})
			if err != nil {
				return e.NotFoundError("Batch not found", nil)
			}

			jobsResponse := []JobResponse{}
			batchSize := len(jobs)
			pendingCount := 0
			processingCount := 0
			successCount := 0
			errorCount := 0

			for _, job := range jobs {
				url := job.GetString("url")
				id := job.Id
				status := job.GetString("status")

				if status == "SUCCESS" {
					download, err := e.App.FindRecordById(collections.Downloads, job.GetString("download"))
					if err != nil || download == nil {
						jobsResponse = append(jobsResponse, JobResponse{
							ID:     id,
							URL:    url,
							Status: status,
						})
					}

					title := download.GetString("title")
					description := download.GetString("description")
					duration := download.GetInt("duration")
					videoId := download.GetString("video_id")
					size := download.GetInt("size")
					downloadEndpoint := "/api/v1/download/" + job.Id

					jobsResponse = append(jobsResponse, JobResponse{
						ID:               id,
						URL:              url,
						Status:           status,
						DownloadEndpoint: downloadEndpoint,
						VideoMetadata: &VideoMetadata{
							Title:       title,
							Description: description,
							Duration:    duration,
							VideoID:     videoId,
							Size:        size,
						},
					})
				} else {
					jobsResponse = append(jobsResponse, JobResponse{
						ID:     id,
						URL:    url,
						Status: status,
					})
				}

				switch status {
				case "PENDING":
					pendingCount++
				case "PROCESSING":
					processingCount++
				case "SUCCESS":
					successCount++
				case "ERROR":
					errorCount++
				}
			}

			batchComplete := successCount+errorCount == batchSize

			return e.JSON(200, map[string]any{
				"batch_id": batchId,
				"jobs":     jobsResponse,
				"finished": batchComplete,
				"counts": map[string]int{
					"pending":    pendingCount,
					"processing": processingCount,
					"success":    successCount,
					"error":      errorCount,
				},
			})
		})

		se.Router.GET("/api/v1/poll/job/{jobId}", func(e *core.RequestEvent) error {
			jobId := e.Request.PathValue("jobId")
			if jobId == "" {
				return e.BadRequestError("Missing jobId parameter", nil)
			}

			job, err := e.App.FindRecordById(collections.Jobs, jobId)
			if err != nil || job == nil {
				return e.NotFoundError("Job not found", nil)
			}

			status := job.GetString("status")
			url := job.GetString("url")

			if status == "SUCCESS" {
				download, err := e.App.FindRecordById(collections.Downloads, job.GetString("download"))
				if err != nil || download == nil {
					return e.NotFoundError("Download not found", nil)
				}

				title := download.GetString("title")
				description := download.GetString("description")
				duration := download.GetInt("duration")
				videoId := download.GetString("video_id")
				size := download.GetInt("size")
				downloadEndpoint := "/api/v1/download/" + job.Id

				return e.JSON(200, JobResponse{
					ID:               job.Id,
					URL:              url,
					Status:           status,
					DownloadEndpoint: downloadEndpoint,
					VideoMetadata: &VideoMetadata{
						Title:       title,
						Description: description,
						Duration:    duration,
						VideoID:     videoId,
						Size:        size,
					},
				})
			} else {
				return e.JSON(200, JobResponse{
					ID:     job.Id,
					URL:    url,
					Status: status,
				})
			}
		})

		se.Router.POST("/api/v1/download/{jobId}", func(e *core.RequestEvent) error {
			jobId := e.Request.PathValue("jobId")
			if jobId == "" {
				return e.BadRequestError("Missing jobId parameter", nil)
			}

			apiKeysCollection, err := app.FindCollectionByNameOrId(collections.APIKeys)
			if err != nil {
				return e.InternalServerError("internal server error", nil)
			}

			authHeader := e.Request.Header.Get("Authorization")
			if authHeader == "" {
				return e.UnauthorizedError("Missing Authorization header", nil)
			}

			apiKey := ""
			if len(authHeader) > 7 && authHeader[:7] == "Bearer " {
				apiKey = authHeader[7:]
			} else {
				return e.UnauthorizedError("Invalid Authorization header format", nil)
			}

			hashedAPIKey := security.SHA256(apiKey)
			apiKeyRecord, err := app.FindFirstRecordByData(apiKeysCollection, "hashed_key", hashedAPIKey)
			if err != nil || apiKeyRecord == nil {
				return e.UnauthorizedError("Invalid API key", nil)
			}

			userId := apiKeyRecord.GetString("user")
			user, err := e.App.FindRecordById(collections.Users, userId)
			if err != nil || user == nil {
				return e.UnauthorizedError("Invalid API key", nil)
			}

			tierId := user.GetString("tier")
			tier, err := e.App.FindRecordById(collections.SubscriptionTiers, tierId)
			if err != nil || tier == nil {
				return e.InternalServerError("something went wrong", nil)
			}

			if tier.GetString("price_id") == "free" {
				return e.ForbiddenError("Free tier users cannot use the API. Please upgrade your subscription.", nil)
			}

			if tier.GetString("lookup_key") == "basic_monthly" || tier.GetString("lookup_key") == "basic_yearly" {
				return e.ForbiddenError("Basic tier users cannot use the API. Please upgrade your subscription.", nil)
			}

			job, err := e.App.FindRecordById(collections.Jobs, jobId)
			if err != nil || job == nil {
				return e.NotFoundError("Job not found", nil)
			}

			if job.GetString("status") != "SUCCESS" {
				return e.BadRequestError("Job has not completed successfully", nil)
			}

			downloadId := job.GetString("download")
			if downloadId == "" {
				return e.BadRequestError("Job does not have an associated download", nil)
			}

			download, err := e.App.FindRecordById(collections.Downloads, downloadId)
			if err != nil || download == nil {
				return e.NotFoundError("Download not found", nil)
			}

			fsys, err := app.NewFilesystem()
			if err != nil {
				return e.InternalServerError("internal server error", nil)
			}
			defer fsys.Close()

			fileKey := download.BaseFilesPath() + "/" + download.GetString("file")

			r, err := fsys.GetReader(fileKey)
			if err != nil {
				return e.InternalServerError("internal server error", nil)
			}
			defer r.Close()

			content := new(bytes.Buffer)
			_, err = io.Copy(content, r)
			if err != nil {
				return e.InternalServerError("internal server error", nil)
			}

			return e.Blob(200, "audio/mpeg", content.Bytes())
		})

		type AddUrlRequestBody struct {
			PodcastID string `json:"podcast_id"`
			URL       string `json:"url"`
		}

		se.Router.POST("/api/v1/podcasts/add-url", func(e *core.RequestEvent) error {
			body := AddUrlRequestBody{}
			if err := e.BindBody(&body); err != nil {
				return e.BadRequestError("failed to parse request body", nil)
			}

			authHeader := e.Request.Header.Get("Authorization")
			if authHeader == "" {
				return e.UnauthorizedError("Missing Authorization header", nil)
			}

			apiKey := ""
			if len(authHeader) > 7 && authHeader[:7] == "Bearer " {
				apiKey = authHeader[7:]
			} else {
				return e.UnauthorizedError("Invalid Authorization header format", nil)
			}

			hashedAPIKey := security.SHA256(apiKey)
			apiKeyRecord, err := e.App.FindFirstRecordByData(collections.APIKeys, "hashed_key", hashedAPIKey)
			if err != nil || apiKeyRecord == nil {
				return e.UnauthorizedError("Invalid API key", nil)
			}

			userId := apiKeyRecord.GetString("user")
			user, err := e.App.FindRecordById(collections.Users, userId)
			if err != nil || user == nil {
				return e.UnauthorizedError("Invalid API key", nil)
			}

			monthlyUsageRecords, err := e.App.FindRecordsByFilter(collections.MonthlyUsage, "user = {:user}", "-created", 1, 0, dbx.Params{
				"user": user.Id,
			})
			if err != nil || monthlyUsageRecords == nil {
				e.App.Logger().Error("Add URL API: failed to find monthly usage record: " + err.Error())
				return e.Next()
			}
			monthlyUsage := monthlyUsageRecords[0]

			usageLimit := monthlyUsage.GetInt("limit")
			currentUsage := monthlyUsage.GetInt("usage")
			if currentUsage >= usageLimit {
				return e.ForbiddenError("Monthly usage limit exceeded", nil)
			}

			itemsCollection, err := e.App.FindCollectionByNameOrId(collections.Items)
			if err != nil {
				return e.InternalServerError("internal server error", nil)
			}

			item := core.NewRecord(itemsCollection)
			item.Set("user", user.Id)
			item.Set("podcast", body.PodcastID)
			item.Set("url", body.URL)
			item.Set("type", "url")
			item.Set("status", "CREATED")
			if err := e.App.Save(item); err != nil {
				return e.InternalServerError("internal server error", nil)
			}

			return e.JSON(http.StatusOK, map[string]string{"status": "success"})
		})

		se.Router.GET("/api/v1/list-podcasts", func(e *core.RequestEvent) error {
			authHeader := e.Request.Header.Get("Authorization")
			if authHeader == "" {
				return e.UnauthorizedError("Missing Authorization header", nil)
			}

			apiKey := ""
			if len(authHeader) > 7 && authHeader[:7] == "Bearer " {
				apiKey = authHeader[7:]
			} else {
				return e.UnauthorizedError("Invalid Authorization header format", nil)
			}

			hashedAPIKey := security.SHA256(apiKey)
			apiKeyRecord, err := app.FindFirstRecordByData(collections.APIKeys, "hashed_key", hashedAPIKey)
			if err != nil || apiKeyRecord == nil {
				return e.UnauthorizedError("Invalid API key", nil)
			}

			userId := apiKeyRecord.GetString("user")
			user, err := e.App.FindRecordById(collections.Users, userId)
			if err != nil || user == nil {
				return e.UnauthorizedError("Invalid API key", nil)
			}

			podcasts, err := e.App.FindAllRecords(collections.Podcasts, dbx.HashExp{"user": user.Id})
			if err != nil {
				return e.NotFoundError("No podcasts found", nil)
			}

			return e.JSON(http.StatusOK, podcasts)
		})

		se.Router.GET(("/api/v1/get-usage"), func(e *core.RequestEvent) error {
			authHeader := e.Request.Header.Get("Authorization")
			if authHeader == "" {
				return e.UnauthorizedError("Missing Authorization header", nil)
			}

			apiKey := ""
			if len(authHeader) > 7 && authHeader[:7] == "Bearer " {
				apiKey = authHeader[7:]
			} else {
				return e.UnauthorizedError("Invalid Authorization header format", nil)
			}

			hashedAPIKey := security.SHA256(apiKey)
			apiKeyRecord, err := app.FindFirstRecordByData(collections.APIKeys, "hashed_key", hashedAPIKey)
			if err != nil || apiKeyRecord == nil {
				return e.UnauthorizedError("Invalid API key", nil)
			}

			userId := apiKeyRecord.GetString("user")
			user, err := e.App.FindRecordById(collections.Users, userId)
			if err != nil || user == nil {
				return e.UnauthorizedError("Invalid API key", nil)
			}

			monthlyUsageRecords, err := e.App.FindRecordsByFilter(collections.MonthlyUsage, "user = {:user}", "-created", 1, 0, dbx.Params{
				"user": user.Id,
			})
			if err != nil || monthlyUsageRecords == nil {
				e.App.Logger().Error("Add URL API: failed to find monthly usage record: " + err.Error())
				return e.Next()
			}
			monthlyUsage := monthlyUsageRecords[0]

			usageLimit := monthlyUsage.GetInt("limit")
			currentUsage := monthlyUsage.GetInt("usage")

			return e.JSON(http.StatusOK, map[string]any{
				"usage": usageLimit,
				"used":  currentUsage,
			})
		})

		se.Router.GET("/api/v1/poll/jobs", func(e *core.RequestEvent) error {
			authHeader := e.Request.Header.Get("Authorization")
			if authHeader == "" {
				return e.UnauthorizedError("Missing Authorization header", nil)
			}

			apiKey := ""
			if len(authHeader) > 7 && authHeader[:7] == "Bearer " {
				apiKey = authHeader[7:]
			} else {
				return e.UnauthorizedError("Invalid Authorization header format", nil)
			}

			hashedAPIKey := security.SHA256(apiKey)
			apiKeyRecord, err := app.FindFirstRecordByData(collections.APIKeys, "hashed_key", hashedAPIKey)
			if err != nil || apiKeyRecord == nil {
				return e.UnauthorizedError("Invalid API key", nil)
			}

			userId := apiKeyRecord.GetString("user")
			user, err := e.App.FindRecordById(collections.Users, userId)
			if err != nil || user == nil {
				return e.UnauthorizedError("Invalid API key", nil)
			}

			jobs, err := e.App.FindRecordsByFilter(collections.Jobs, "user = {:user}", "-created", 0, 0, dbx.Params{
				"user": user.Id,
			})
			if err != nil {
				return e.NotFoundError("No jobs found", nil)
			}

			jobsResponse := []JobResponse{}
			for _, job := range jobs {
				url := job.GetString("url")
				id := job.Id
				status := job.GetString("status")
				title := job.GetString("title")
				createdAt := job.GetString("created")

				jobsResponse = append(jobsResponse, JobResponse{
					ID:     id,
					URL:    url,
					Status: status,
					Title:  title,
					Created: createdAt,
				})
			}

			return e.JSON(200, map[string]any{
				"jobs": jobsResponse,
			})
		})

		return se.Next()
	})

	return nil
}
